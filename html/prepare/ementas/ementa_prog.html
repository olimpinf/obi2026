title:Ementa – Modalidade Programação
template:flatpages_prepare.html

<p>A Ementa da Modalidade Programação indica os conhecimentos
  esperados dos competidores em cada nível. A ementa foi compilada
  com base na <a href=
  "https://ioinformatics.org/files/ioi-syllabus-2024.pdf">Ementa da
  Olimpíada Internacional de Informática</a>.</p>
  <p>As seguintes convenções são utilizadas para definir os tópicos
  que podem ser cobrados na OBI em cada um de seus níveis:</p>
  <table class="table bordered">
    <tr class="row-dark">
      <td valign="top">[PJ]</td>
      <td>Tópico que pode ser cobrado a partir do Nível
      Júnior.</td>
    </tr>
    <tr class="row-light">
      <td valign="top">[P1]</td>
      <td>Tópico que pode ser cobrado a partir do Nível 1.</td>
    </tr>
    <tr class="row-dark">
      <td valign="top">[P2]</td>
      <td>Tópico que pode ser cobrado somente para o Nível 2 e o
      Nível Sênior.</td>
    </tr>
  </table>
  <h3>Fundamentos de Matemática</h3>
  <p><span>Competidores devem estar familiarizados com os conceitos
  matemáticos a seguir, necessários para o desenvolvimento e
  análise de algoritmos.</span></p>
  <h4 id="h.cx7c3uifwbq4"><span>Conceitos de Aritmética e
  Geometria</span></h4>
  <ul>
    <li><span>[PJ] Números inteiros, operações (incluindo
    exponenciação) e comparações</span></li>
    <li><span>[PJ] Propriedades básicas dos inteiros (sinal,
    paridade, divisibilidade)</span></li>
    <li><span>[PJ] Números primos</span></li>
    <li><span>[PJ] Frações, porcentagens</span></li>
    <li><span>[PJ] Reta, segmento de reta, ângulo, triângulo,
    retângulo, quadrado, círculo</span></li>
    <li><span>[PJ] Ponto, coordenadas no plano</span></li>
    <li><span>[PJ] Polígono (vértice, aresta/lado, simples,
    convexo, área)</span></li>
    <li><span>[PJ] Distâncias euclidianas</span></li>
    <li><span>[PJ] Teorema de Pitágoras</span></li>
    <li><span>[P1] Aritmética modular básica: adição, subtração,
    multiplicação</span></li>
  </ul>
  <h4 id="h.1oobbv6i3whf"><span>Fundamentos de Lógica</span></h4>
  <ul>
    <li><span>[PJ] Lógica de primeira ordem:</span></li>
    <ul>
      <li><span>Proposições verdadeiras e falsas</span></li>
      <li><span>Conectivos básicos (“e”, “ou”, “não”)</span></li>
      <li><span>Quantificadores existenciais e universais (“existe
	  um”, “para todo”)</span></li>
      <li><span>Implicação lógica (“se…, então…”)</span></li>
      <li><span>Bicondicional (“se e somente se”)</span></li>
      <li><span>Tabelas-verdade</span></li>
      <li><span>Modus Ponens</span><span>&nbsp;e</span> <span>Modus
	  Tollens</span><sup><a href="#cmnt6" id=
				"cmnt_ref6">[f]</a></sup></li>
    </ul>
  </ul>
  <ul>
    <li><span>[PJ] Demonstrações matemáticas: provas diretas, por
    contradição, por contrapositiva ou contraexemplo</span></li>
    <li><span>[P1] Demonstrações pelo princípio de indução
    matemática, incluindo indução forte</span></li>
  </ul>
  <p><span>[Obs.: A Modalidade Programação é uma competição prática
  e não exige que o competidor escreva demonstrações teóricas para
  seus algoritmos. No entanto, o conhecimento das técnicas de
  demonstração acima é fortemente</span>
  <span>recomendada</span><sup><a href="#cmnt7" id=
  "cmnt_ref7">[g]</a></sup><span>&nbsp;para o desenvolvimento de
  habilidades de resolução de problemas.]</span></p>
  <h4 id="h.1cmsvo6q5e1b"><span>Conceitos de Matemática
  Discreta</span></h4>
  <ul>
    <li><span>[PJ] Funções e relações</span></li>
    <li><span>[PJ] Ordem lexicográfica</span></li>
    <li><span>[PJ] Conjuntos (união/interseção,
    complemento)</span></li>
    <li><span>[PJ] Recursão (definições matemáticas
    recursivas)</span></li>
    <li><span>[PJ] Argumentos de contagem (princípio aditivo,
    princīpio multiplicativo)</span></li>
    <li><span>[PJ] Permutações e função fatorial</span></li>
    <li><span>[PJ] Progressão aritmética</span></li>
    <li><span>[PJ] Princípio da casa dos pombos</span></li>
    <li><span>[PJ] Teoria dos jogos básica (posições vencedoras e
    perdedoras)</span></li>
    <li><span>[P1] Progressão geométrica</span></li>
    <li><span>[P1] Combinações</span></li>
    <li><span>[P1] Triângulo de Pascal e coeficientes
    binomiais</span></li>
    <li><span>[P1] Princípio da inclusão-exclusão</span></li>
  </ul>
  <h4 id="h.hvlslx2qlbtp"><span>Conceitos de Grafos</span></h4>
  <ul>
    <li><span>[PJ] Grafos não-direcionados (vértice/nó, aresta,
    grau, adjacência, vértices ou arestas com pesos)</span></li>
    <li><span>[PJ] Grafos direcionados (grau de entrada, grau de
    saída)</span></li>
    <li><span>[PJ] Caminhos e ciclos</span></li>
    <li><span>[PJ] Componentes conexas</span></li>
    <li><span>[PJ] Árvores e florestas</span></li>
    <li><span>[PJ] Lema do aperto de mão</span><sup><a href=
    "#cmnt8" id="cmnt_ref8">[h]</a></sup></li>
    <li><span>[P1] Árvores enraizadas (raiz, folha, pai, filho,
    ancestral, descendente, subárvore, profundidade)</span></li>
  </ul>
  <h3 id="h.xio5gm6yw78u"><span>Fundamentos de
  Computação</span></h3>
  <p><span>Competidores devem ser capazes de usar um computador
  comum para acessar o ambiente online de prova e implementar
  soluções para as tarefas apresentadas em uma das linguagens de
  programação disponíveis. Deste modo, competidores devem estar
  familiarizados com os tópicos a seguir.</span></p>
  <h4 id="h.r1vwack0ji0t"><span>Informática Básica</span></h4>
  <ul>
    <li><span>[PJ] Estrutura básica de um computador (componentes,
    CPU, memória)</span></li>
    <li><span>[PJ] Uso básico de um sistema operacional com
    interface gráfica (Windows e Linux) e seus aplicativos padrão
    (editor de texto, navegador, calculadora)</span></li>
    <li><span>[PJ] Administração básica de arquivos (criar, copiar
    ou mover pastas e arquivos)</span></li>
  </ul>
  <h4 id="h.tl9w5yqnnkla"><span>Programação</span></h4>
  <ul>
    <li><span>[PJ] Criação, compilação e execução de programas de
    computador em uma das linguagens disponíveis com o uso de uma
    IDE (Integrated Development Environment) ou terminal/linha de
    comando</span></li>
    <li><span>[PJ] Sintaxe e semântica básica em uma das linguagens
    disponíveis</span></li>
    <li><span>[PJ] Variáveis, expressões e atribuições</span></li>
    <li><span>[PJ] Variáveis dos tipos primitivos: números
    inteiros, números reais, booleanos, caracteres</span></li>
    <li><span>[PJ] Operadores aritméticos (adição, subtração,
    multiplicação, divisão inteira, divisão real, resto da
    divisão)</span></li>
    <li><span>[PJ] Leitura da entrada padrão e impressão para a
    saída padrão</span></li>
    <li><span>[PJ] Estruturas condicionais simples e
    compostas</span></li>
    <li><span>[PJ] Estruturas de repetição simples e
    encadeadas</span></li>
    <li><span>[PJ] Operadores lógicos
    (</span><span>e</span><span>,</span>
    <span>ou</span><span>,</span>
    <span>negação</span><span>)</span></li>
    <li><span>[PJ] Cadeias de caracteres
    (</span><span>strings</span><span>)</span></li>
    <li><span>[PJ] Vetores, incluindo vetores
    multidimensionais</span></li>
    <li><span>[PJ] Funções e parâmetros</span></li>
    <li><span>[PJ] Recursão</span></li>
    <li><span>[PJ] Conceitos básicos de alocação de memória:
    alocação estática, pilha de recursão, tamanhos em bytes dos
    tipos primitivos</span></li>
    <li><span>[PJ] Ponteiros e referências</span></li>
    <li><span>[P1] Representação binária de inteiros e operadores
    binários:</span> <span>e</span><span>,</span>
    <span>ou</span><span>,</span>
    <span>ou-exclusivo</span><span>,</span>
    <span>negação</span><span>,</span> <span>deslocamento de
    bits</span><span>&nbsp;(</span><span>shifts</span><span>)</span></li>
  </ul>
  <h3 id="h.g8jbgbfvd13r"><span>Algoritmos e Estruturas de
  Dados</span></h3>
  <p><span>O foco da Modalidade Programação é a resolução de
  problemas por meio do desenvolvimento, análise e implementação de
  algoritmos e estruturas de dados eficientes. Os competidores
  devem</span> <span>aplicar, adaptar e
  combinar</span><span>&nbsp;os algoritmos e estratégias listados
  abaixo para resolver as tarefas propostas.</span></p>
  <h4 id="h.xmc4dr9e0dul"><span>Fundamentos de Análise de
  Algoritmos</span></h4>
  <ul>
    <li><span>[PJ] Conceito de algoritmo (especificação,
    invariantes, corretude, eficiência, pré-condição e
    pós-condição)</span></li>
    <li><span>[PJ] Análise assintótica de complexidade
    (informal):</span></li>
    <ul>
      <li><span>Notação</span> <span>Big O</span></li>
      <li><span>Classes de complexidade padrão: constante,
	  logarítmico, linear,</span> <img src=
					   "/static/assets/img/ementa/image1.png"><span>, quadrático,
	  cúbico, exponencial, fatorial, etc.</span></li>
      <li><span>Trade-off</span><span>&nbsp;espaço-tempo</span></li>
      <li><span>Análise amortizada (informal)</span></li>
    </ul>
    <li><span>[PJ] Medidas empíricas de performance (estimar o
    tempo de execução e consumo de memória de um
    programa)</span></li>
  </ul>
  <h4 id="h.uanwfhj8yjzn"><span>Estratégias de
  Algoritmos</span></h4>
  <ul>
    <li><span>[PJ] Estratégias simples de iteração e
    repetição</span></li>
    <li><span>[PJ] Algoritmos de força-bruta (busca
    exaustiva)</span></li>
    <li><span>[PJ] Algoritmos gulosos (incluindo argumentos de
    corretude)</span></li>
    <li><span>[P1]</span>
    <span>Backtracking</span><span>&nbsp;(busca exaustiva
    recursiva) simples e com podas</span></li>
    <li><span>[P1] Conceito de divisão-e-conquista</span></li>
    <li><span>[P1] Programação dinâmica</span></li>
  </ul>
  <h4 id="h.kbl0wag4d9aj"><span>Estruturas de Dados</span></h4>
  <ul>
    <li><span>[PJ] Histograma (Vetor de Frequências)</span></li>
    <li><span>[PJ] Somas Parciais (soma/máximo/mínimo de
    prefixo/sufixo)</span></li>
    <li><span>[PJ] Conjunto (</span><span>Set</span><span>) com
    implementação da biblioteca padrão</span></li>
    <li><span>[PJ] Dicionário (</span><span>Map</span><span>) com
    implementação da biblioteca padrão</span></li>
    <li><span>[PJ] Fila de Prioridades
    (</span><span>Heap</span><span>&nbsp;Binário) com implementação
    da biblioteca padrão</span></li>
    <li><span>[PJ] Pilha e Fila</span></li>
    <li><span>[PJ] Representações de grafos: Lista de Arestas,
    Lista de Adjacências, Matriz de Adjacências</span></li>
    <li><span>[P1] Representação de conjuntos disjuntos com</span>
    <span>Union-Find</span></li>
    <li><span>[P1] Árvore de Índices Binários (BIT ou</span>
    <span>Fenwick Tree</span><span>) 1D</span></li>
    <li><span>[P2] Tabela Esparsa (</span><span>Sparse
    Table</span><span>) em vetores estáticos;</span> <span>Range
    Minimum Query</span><span>&nbsp;em</span> <img src=
    "/static/assets/img/ementa/image2.png"></li>
    <li><span>[P2] Árvore de Segmentos (</span><span>Segment
    Tree</span><span>) 1D, incluindo técnica de</span> <span>Lazy
    Propagation</span></li>
  </ul>
  <h4 id="h.tad0uxqqvau2"><span>Algoritmos de Ordenação e
  Busca</span></h4>
  <ul>
    <li><span>[PJ] Ordenação em</span> <img src=
    "/static/assets/img/ementa/image3.png"><span>&nbsp;com função
    da biblioteca padrão, incluindo funções de
    comparação</span></li>
    <li><span>[PJ]</span> <span>Counting Sort</span></li>
    <li><span>[PJ] Técnica de Dois Ponteiros (</span><span>Two
    Pointers</span><span>)</span></li>
    <li><span>[PJ] Busca Binária, incluindo Busca Binária na
    Resposta</span></li>
    <li><span>[P2] Ordenação em</span> <img src=
    "/static/assets/img/ementa/image3.png"><span>&nbsp;com</span>
    <span>Merge Sort</span></li>
    <li><span>[P2] Busca com técnica</span>
    <span>Meet-in-the-Middle</span></li>
  </ul>
  <h4 id="h.dhygsqy3uyw4"><span>Algoritmos de
  Matemática</span></h4>
  <ul>
    <li><span>[PJ] Conversão entre bases numéricas</span></li>
    <li><span>[PJ] Algoritmo de Euclides para o máximo divisor
    comum</span></li>
    <li><span>[PJ] Divisão por Tentativas: testar primalidade e
    listar divisores em</span> <img src=
    "/static/assets/img/ementa/image4.png"></li>
    <li><span>[PJ] Crivo de Eratóstenes</span></li>
    <li><span>[PJ] Fatoração (com crivo ou divisão por
    tentativas)</span></li>
    <li><span>[P1] Exponenciação Rápida</span></li>
  </ul>
  <h4 id="h.r90z4becje49"><span>Algoritmos de Programação
  Dinâmica</span></h4>
  <ul>
    <li><span>[P1] Problema da Mochila (Knapsack) com e sem
    repetições</span></li>
    <li><span>[P1] Contagem com programação dinâmica</span></li>
    <li><span>[P1] Programação dinâmica em prefixos de
    vetores/matrizes (por exemplo, Algoritmo de Kadane, Maior
    Subsequência Comum, Distância de Edição)</span></li>
    <li><span>[P1] Programação dinâmica para resolver jogos
    (posições vencedoras e perdedoras, Minimax)</span></li>
    <li><span>[P1] Maior Subsequência Crescente em</span> <img src=
    "/static/assets/img/ementa/image3.png"></li>
    <li><span>[P2] Programação dinâmica em grafos direcionados
    acíclicos (por exemplo, Problema do Caminho Mais
    Longo)</span></li>
    <li><span>[P2] Programação dinâmica em intervalos de
    vetores/matrizes (por exemplo, Multiplicação de Cadeia de
    Matrizes)</span></li>
    <li><span>[P2] Programação dinâmica com máscara de bits (por
    exemplo, encontrar caminho Hamiltoniano)</span></li>
  </ul>
  <h4 id="h.h4ro1t2wthdt"><span>Algoritmos em Grafos</span></h4>
  <ul>
    <li><span>[PJ] Busca em Profundidade (DFS), incluindo
    aplicações:</span></li>
    <ul>
      <li><span>Encontrar componentes conexas</span></li>
      <li><span>Encontrar bipartição</span></li>
      <li><span>Preenchimento por Inundação (</span><span>Flood
	  Fill</span><span>&nbsp;/ DFS em</span>
	<span>grids</span><span>)</span></li>
    </ul>
    <li><span>[PJ] Busca em Largura (BFS)</span></li>
    <li><span>[P1] Algoritmo de Dijkstra</span></li>
    <li><span>[P1] Árvore geradora mínima (algoritmos de Prim e
	Kruskal)</span></li>
    <li><span>[P1] Ordenação topológica (algoritmo de
	Kahn)</span></li>
    <li><span>[P2] Algoritmos de Bellman-Ford e
	Floyd-Warshall</span></li>
    <li>[P2] Aplicações de árvore geradora da DFS
      (DFS traversal tree),
      incluindo:</li>
    <ul>
      <li><span>Caminho/ciclo de Euler</span></li>
      <li><span>Algoritmos de Tarjan para pontes e pontos de
	  articulação</span></li>
    </ul>
    <li><span>[P2] Componentes fortemente conexas (algoritmo de
    Kosaraju ou Tarjan)</span></li>
  </ul>
  <h4 id="h.o0ns0u6pwzye"><span>Algoritmos em Árvores</span></h4>
  <ul>
    <li><span>[P1] Aumentação de subárvores em árvores enraizadas
    (por exemplo, calcular o tamanho ou a folha mais distante para
    cada subárvore)</span></li>
    <li><span>[P1] Diâmetro e centro de árvore em</span> <img src=
    "/static/assets/img/ementa/image5.png"></li>
    <li><span>[P2] Grafos funcionais (decomposição em ciclos e
    árvores)</span></li>
    <li><span>[P2]</span> <span>Binary Lifting</span><span>&nbsp;e
    Ancestral Comum Mais Profundo (LCA) em</span> <img src=
    "/static/assets/img/ementa/image2.png"></li>
    <li><span>[P2] Pré-ordem, em-ordem, pós-ordem e técnica de
    Linearização de Árvore (</span><span>Euler Tour
    Technique</span><span>)</span></li>
    <li><span>[P2] Programação dinâmica em árvores enraizadas com
    técnica de Girar Raiz (</span><span>Tree
    Rerooting</span><span>)</span></li>
    <li><span>[P2] Técnica</span>
    <span>Small-to-Large</span><span>&nbsp;para unir
    subárvores</span></li>
  </ul>
  <h4 id="h.p88ll6a9id8l"><span>Algoritmos de Geometria</span></h4>
  <ul>
    <li><span>[P2] Representação de vetores, retas e segmentos de
    reta</span></li>
    <li><span>[P2] Compressão de coordenadas</span></li>
    <li><span>[P2] Produto escalar e vetorial, incluindo
    aplicações:</span></li>
    <ul>
      <li><span>Checar se três pontos são colineares</span></li>
      <li><span>Testar se dois vetores são
	  paralelos/ortogonais</span></li>
      <li><span>Calcular sentido do ângulo entre dois
	  vetores</span></li>
    </ul>
    <li><span>[P2] Interseção de duas retas</span></li>
    <li><span>[P2] Técnicas de Varredura (</span><span>Line
    Sweep</span><span>,</span> <span>Radial
    Sweep</span><span>)</span></li>
    <li><span>[P2] Fecho Convexo (</span><span>Convex
    Hull</span><span>) em</span> <img src=
    "/static/assets/img/ementa/image1.png"></li>
    <li><span>[P2] Área de polígono em</span> <img src=
    "/static/assets/img/ementa/image5.png"><span>&nbsp;(Fórmula do
    Cadarço ou equivalente)</span></li>
    <li><span>[P2] Checar se um ponto está em um polígono em</span>
    <img valign="middle" src="/static/assets/img/ementa/image5.png"><span>&nbsp;(</span><span>Ray
    Casting</span><span>&nbsp;ou equivalente)</span></li>
  </ul>
</body>
</html>
