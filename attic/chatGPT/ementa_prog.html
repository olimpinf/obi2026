title:Ementa – Modalidade Programação
template:flatpages_prepare.html

<p>A Ementa da Modalidade Programa&ccedil;&atilde;o indica os conhecimentos esperados dos competidores em cada n&iacute;vel. A ementa foi compilada com base na <a href="https://www.google.com/url?q=https://ioinformatics.org/files/ioi-syllabus-2023.pdf&amp;sa=D&amp;source=editors&amp;ust=1708531927198487&amp;usg=AOvVaw2tsVvKn2QgDaV9b14XEVsV">Ementa da Olimp&iacute;ada Internacional de Inform&aacute;tica</a>.</p>

<p>As seguintes convenções são utilizadas para definir os tópicos que podem ser cobrados na OBI em cada um
de seus níveis:</p>
<table class="table bordered"> 
  <tr class="row-dark">
    <td valign="top">[PJ]</td><td> Tópico que pode ser cobrado a partir do Nível Júnior.</td></tr>
  <tr class="row-light">
    <td valign="top">[P1]</td><td> Tópico que pode ser cobrado a partir do Nível 1.</td></tr>
  <tr class="row-dark">
    <td valign="top">[P2]</td><td> Tópico que pode ser cobrado somente para o Nível 2 e o Nível Sênior.</td></tr>
</table>

        <p></p>
        <h2 id="h.45i71m6kwfja">1. Fundamentos de Matem&aacute;tica</h2>
        <p>Competidores devem estar familiarizados com os conceitos matem&aacute;ticos a seguir, necess&aacute;rios para o desenvolvimento e an&aacute;lise de algoritmos.</p>
        <h4 id="h.cx7c3uifwbq4">Conceitos de Aritm&eacute;tica e Geometria</h4>
        <ul>
            <li>[PJ] N&uacute;meros inteiros, opera&ccedil;&otilde;es (incluindo exponencia&ccedil;&atilde;o) e compara&ccedil;&otilde;es</li>
            <li>[PJ] Propriedades b&aacute;sicas dos inteiros (sinal, paridade, divisibilidade)</li>
            <li>[PJ] N&uacute;meros primos</li>
            <li>[PJ] Fra&ccedil;&otilde;es, porcentagens</li>
            <li>[PJ] Reta, segmento de reta, &acirc;ngulo, tri&acirc;ngulo, ret&acirc;ngulo, quadrado, c&iacute;rculo</li>
            <li>[PJ] Ponto, coordenadas no plano</li>
            <li>[PJ] Pol&iacute;gono (v&eacute;rtice, aresta/lado, simples, convexo, &aacute;rea)</li>
            <li>[PJ] Dist&acirc;ncias euclidianas</li>
            <li>[PJ] Teorema de Pit&aacute;goras</li>
            <li>[P1] Aritm&eacute;tica modular b&aacute;sica: adi&ccedil;&atilde;o, subtra&ccedil;&atilde;o, multiplica&ccedil;&atilde;o</li>
        </ul>
        <h4 id="h.1oobbv6i3whf">Fundamentos de L&oacute;gica</h4>
        <ul>
          <li>[PJ] L&oacute;gica de primeira ordem:</li>
          <ul>
            <li>Proposi&ccedil;&otilde;es verdadeiras e falsas</li>
            <li>Conectivos b&aacute;sicos (&ldquo;e&rdquo;, &ldquo;ou&rdquo;, &ldquo;n&atilde;o&rdquo;)</li>
            <li>Quantificadores existenciais e universais (&ldquo;existe um&rdquo;, &ldquo;para todo&rdquo;)</li>
            <li>Implica&ccedil;&atilde;o l&oacute;gica (&ldquo;se&hellip;, ent&atilde;o&hellip;&rdquo;)</li>
            <li>Bicondicional (&ldquo;se e somente se&rdquo;)</li>
            <li>Tabelas-verdade</li>
            <li><em>Modus Ponens</em> e <em>Modus Tollens</em></li>
          </ul>
          <li>[PJ] Demonstra&ccedil;&otilde;es matem&aacute;ticas: provas diretas, por contradi&ccedil;&atilde;o, por contrapositiva ou contraexemplo</li>
          <li>[P1] Demonstra&ccedil;&otilde;es pelo princ&iacute;pio de indu&ccedil;&atilde;o matem&aacute;tica, incluindo indu&ccedil;&atilde;o forte</li>
        </ul>
        <p></p>
        <p><em>Obs.: A Modalidade Programa&ccedil;&atilde;o &eacute; uma competi&ccedil;&atilde;o pr&aacute;tica e n&atilde;o exige que o competidor escreva demonstra&ccedil;&otilde;es te&oacute;ricas para seus algoritmos. No entanto, o conhecimento das t&eacute;cnicas de demonstra&ccedil;&atilde;o acima &eacute; fortemente recomendado para o desenvolvimento de habilidades de resolu&ccedil;&atilde;o de problemas.</em></p>
        <h4 id="h.1cmsvo6q5e1b">Conceitos de Matem&aacute;tica Discreta</h4>
        <ul>
            <li>[PJ] Fun&ccedil;&otilde;es e rela&ccedil;&otilde;es</li>
            <li>[PJ] Ordem lexicogr&aacute;fica</li>
            <li>[PJ] Conjuntos (uni&atilde;o/interse&ccedil;&atilde;o, complemento)</li>
            <li>[PJ] Recurs&atilde;o (defini&ccedil;&otilde;es matem&aacute;ticas recursivas)</li>
            <li>[PJ] Argumentos de contagem (princ&iacute;pio aditivo, princípio multiplicativo)</li>
            <li>[PJ] Permuta&ccedil;&otilde;es e fun&ccedil;&atilde;o fatorial</li>
            <li>[PJ] Progress&atilde;o aritm&eacute;tica</li>
            <li>[PJ] Princ&iacute;pio da casa dos pombos</li>
            <li>[PJ] Teoria dos jogos b&aacute;sica (posi&ccedil;&otilde;es vencedoras e perdedoras)</li>
            <li>[P1] Progress&atilde;o geom&eacute;trica</li>
            <li>[P1] Combina&ccedil;&otilde;es</li>
            <li>[P1] Tri&acirc;ngulo de Pascal e coeficientes binomiais</li>
            <li>[P1] Princ&iacute;pio da inclus&atilde;o-exclus&atilde;o</li>
        </ul>
        <h4 id="h.hvlslx2qlbtp">Conceitos de Grafos</h4>
        <ul>
            <li>[PJ] Grafos n&atilde;o-direcionados (v&eacute;rtice/n&oacute;, aresta, grau, adjac&ecirc;ncia, v&eacute;rtices ou arestas com pesos)</li>
            <li>[PJ] Grafos direcionados (grau de entrada, grau de sa&iacute;da)</li>
            <li>[PJ] Caminhos e ciclos</li>
            <li>[PJ] Componentes conexas</li>
            <li>[PJ] &Aacute;rvores e florestas</li>
            <li>[PJ] Lema do aperto de m&atilde;o</li>
            <li>[P1] &Aacute;rvores enraizadas (raiz, folha, pai, filho, ancestral, descendente, sub&aacute;rvore, profundidade)</li>
        </ul>
        <h2 id="h.xio5gm6yw78u">2. Fundamentos de Computa&ccedil;&atilde;o</h2>
        <p>Competidores devem ser capazes de usar um computador comum para acessar o ambiente online de prova e implementar solu&ccedil;&otilde;es para as tarefas apresentadas em uma das linguagens de programa&ccedil;&atilde;o dispon&iacute;veis. Deste modo, competidores devem estar familiarizados com os t&oacute;picos a seguir.</p>
        <h4 id="h.r1vwack0ji0t">Inform&aacute;tica B&aacute;sica</h4>
        <ul>
            <li>[PJ] Estrutura b&aacute;sica de um computador (componentes, CPU, mem&oacute;ria)</li>
            <li>[PJ] Uso b&aacute;sico de um sistema operacional com interface gr&aacute;fica (Windows e Linux) e seus aplicativos padr&atilde;o (editor de texto, navegador, calculadora)</li>
            <li>[PJ] Administra&ccedil;&atilde;o b&aacute;sica de arquivos (criar, copiar ou mover pastas e arquivos)</li>
        </ul>
        <h4 id="h.tl9w5yqnnkla">Programa&ccedil;&atilde;o</h4>
        <ul>
            <li>[PJ] Cria&ccedil;&atilde;o, compila&ccedil;&atilde;o e execu&ccedil;&atilde;o de programas de computador em uma das linguagens dispon&iacute;veis com o uso de uma IDE (Integrated Development Environment) ou terminal/linha de comando</li>
            <li>[PJ] Sintaxe e sem&acirc;ntica b&aacute;sica em uma das linguagens dispon&iacute;veis</li>
            <li>[PJ] Vari&aacute;veis, express&otilde;es e atribui&ccedil;&otilde;es</li>
            <li>[PJ] Vari&aacute;veis dos tipos primitivos: n&uacute;meros inteiros, n&uacute;meros reais, booleanos, caracteres</li>
            <li>[PJ] Operadores aritm&eacute;ticos (adi&ccedil;&atilde;o, subtra&ccedil;&atilde;o, multiplica&ccedil;&atilde;o, divis&atilde;o inteira, divis&atilde;o real, resto da divis&atilde;o)</li>
            <li>[PJ] Leitura da entrada padr&atilde;o e impress&atilde;o para a sa&iacute;da padr&atilde;o</li>
            <li>[PJ] Estruturas condicionais simples e compostas</li>
            <li>[PJ] Estruturas de repeti&ccedil;&atilde;o simples e encadeadas</li>
            <li>[PJ] Operadores l&oacute;gicos (<u>e</u>, <u>ou</u>, <u>negação</u>)</li>
            <li>[PJ] Cadeias de caracteres (<em>strings</em>)</li>
            <li>[PJ] Vetores, incluindo vetores multidimensionais</li>
            <li>[PJ] Fun&ccedil;&otilde;es e par&acirc;metros</li>
            <li>[PJ] Recurs&atilde;o</li>
            <li>[PJ] Conceitos b&aacute;sicos de aloca&ccedil;&atilde;o de mem&oacute;ria: aloca&ccedil;&atilde;o est&aacute;tica, pilha de recurs&atilde;o, tamanhos em bytes dos tipos primitivos</li>
            <li>[PJ] Ponteiros e refer&ecirc;ncias</li>
            <li>[P1] Representa&ccedil;&atilde;o bin&aacute;ria de inteiros e operadores bin&aacute;rios: <u>e</u>, <u>ou</u>, <u>ou-exclusivo</u>, <u>negação</u>, <u>deslocamentos de bits</u> (<em>shifts</em>)</li>
        </ul>
        <h2 id="h.g8jbgbfvd13r">3. Algoritmos e Estruturas de Dados</h2>
        <p>O foco da Modalidade Programa&ccedil;&atilde;o &eacute; o desenvolvimento, an&aacute;lise e implementa&ccedil;&atilde;o de algoritmos e estruturas de dados eficientes. Os competidores devem <b>aplicar</b>, <b>adaptar</b> e <b>combinar</b> os algoritmos e estrat&eacute;gias listados abaixo para resolver as tarefas propostas.</p>
        <h4 id="h.xmc4dr9e0dul">Fundamentos de An&aacute;lise de Algoritmos</h4>
        <ul>
            <li>[PJ] Conceito de algoritmo (especifica&ccedil;&atilde;o, invariantes, corretude, pr&eacute;-condi&ccedil;&atilde;o e p&oacute;s-condi&ccedil;&atilde;o)</li>
            <li>[PJ] An&aacute;lise assint&oacute;tica de complexidade (informal):</li>
            <ul>
              <li>Nota&ccedil;&atilde;o Big O</li>
              <li>Classes de complexidade padr&atilde;o: constante, logar&iacute;tmico, linear, <em>O(N </em>log&thinsp;<em>N)</em>, quadr&aacute;tico, c&uacute;bico, exponencial, fatorial, etc.</li>
              <li>Compromisso espa&ccedil;o-tempo</li>
              <li>An&aacute;lise amortizada (informal)</li>
            </ul>

            <li>[PJ] Medidas emp&iacute;ricas de performance (estimar o tempo de execu&ccedil;&atilde;o e consumo de mem&oacute;ria de um programa)</li>
        </ul>
        <h4 id="h.uanwfhj8yjzn">Estrat&eacute;gias de Algoritmos</h4>
        <ul>
            <li>[PJ] Estrat&eacute;gias simples de itera&ccedil;&atilde;o e repeti&ccedil;&atilde;o</li>
            <li>[PJ] Algoritmos de for&ccedil;a-bruta (busca exaustiva)</li>
            <li>[PJ] Algoritmos gulosos (incluindo argumentos de corretude)</li>
            <li>[PJ] Divis&atilde;o-e-conquista</li>
            <li>[PJ] <em>Backtracking</em> simples (busca exaustiva recursiva)</li>
            <li>[P1] <em>Backtracking</em> com podas</li>
            <li>[P1] Programa&ccedil;&atilde;o din&acirc;mica</li>
        </ul>
        <h4 id="h.kbl0wag4d9aj">Estruturas de Dados</h4>
        <ul>
            <li>[PJ] Histograma (Vetor de Frequ&ecirc;ncias)</li>
            <li>[PJ] Somas Parciais (soma/m&aacute;ximo/m&iacute;nimo de prefixo/sufixo)</li>
            <li>[PJ] Conjunto (<em>Set</em>) com implementa&ccedil;&atilde;o da biblioteca padr&atilde;o</li>
            <li>[PJ] Dicion&aacute;rio (<em>Map</em>) com implementa&ccedil;&atilde;o da biblioteca padr&atilde;o</li>
            <li>[PJ] Fila de Prioridades (<em>Heap</em> Bin&aacute;rio) com implementa&ccedil;&atilde;o da biblioteca padr&atilde;o</li>
            <li>[PJ] Pilha e Fila</li>
            <li>[PJ] Representa&ccedil;&otilde;es de grafos: Lista de Arestas, Lista de Adjac&ecirc;ncias, Matriz de Adjac&ecirc;ncias</li>
            <li>[P1] Lista Ligada</li>
            <li>[P1] Representa&ccedil;&atilde;o de conjuntos disjuntos com Union-Find</li>
            <li>[P2] Tabela Esparsa (<em>Sparse Table</em>) em vetores est&aacute;ticos, <em>Range Minimum Query</em> em <em>O</em>(log&thinsp;<em>N</em>) <em>O</em>(log&thinsp;<em>N</em>)</li>
            <li>[P2] Decomposi&ccedil;&atilde;o <img src="/static/assets/img/ementa/n_root.svg" height="26px"> simples:</li>
            <ul>
              <li>Decomposi&ccedil;&atilde;o de estruturas est&aacute;ticas</li>
              <li>Divis&atilde;o entre casos pequenos e casos grandes (&ldquo;truque de leves e pesados&rdquo;)</li>
            </ul>

            <li>[P2] &Aacute;rvore de &Iacute;ndices Bin&aacute;rios (BIT ou <em>Fenwick Tree</em>) 1D</li>
            <li>[P2] &Aacute;rvore de Segmentos (</em>Segment Tree</em>) 1D, incluindo:</li>

            <ul>
              <li>T&eacute;cnica de <em>Lazy Propagation</em></li>
            <li><em>Merge Sort Tree</em></li>
            </ul>

            <li>[P2] &Aacute;rvore de Prefixos (Trie)</li>
        </ul>

        <h4 id="h.tad0uxqqvau2">Algoritmos de Ordena&ccedil;&atilde;o e Busca</h4>
        <ul>
            <li>[PJ] Ordena&ccedil;&atilde;o em <em>O</em>(<em>N</em> log&thinsp;<em>N</em>) com fun&ccedil;&atilde;o da biblioteca padr&atilde;o, incluindo fun&ccedil;&otilde;es de compara&ccedil;&atilde;o</li>
            <li>[PJ] Ordena&ccedil;&atilde;o em <em>O</em>(<em>N</em> log&thinsp;<em>N</em>) com <em>Merge Sort</em> e <em>Heap Sort</em></li>
            <li>[PJ] Ordenação por contagem (<em>Counting Sort</em>)</li>
            <li>[PJ] T&eacute;cnica de Dois Ponteiros (<em>Two Pointers</em>)</li>
            <li>[PJ] Busca Bin&aacute;ria, incluindo Busca Bin&aacute;ria na Resposta</li>
            <li>[P2] Busca com t&eacute;cnica <em>Meet-in-the-Middle</em></li>
        </ul>
        <h4 id="h.dhygsqy3uyw4">Algoritmos de Matem&aacute;tica</h4>
        <ul>
            <li>[PJ] Convers&atilde;o entre bases num&eacute;ricas</li>
            <li>[PJ] Algoritmo de Euclides para o m&aacute;ximo divisor comum</li>
            <li>[PJ] Divis&atilde;o por Tentativas: testar primalidade e listar divisores em <em>O</em>(<img src="/static/assets/img/ementa/n_root.svg" height="26px">)</li>
            <li>[PJ] Crivo de Erat&oacute;stenes</li>
            <li>[PJ] Fatora&ccedil;&atilde;o (com crivo ou divis&atilde;o por tentativas)</li>
            <li>[P1] Exponencia&ccedil;&atilde;o R&aacute;pida</li>
            <li>[P1] Algoritmo Minimax para otimiza&ccedil;&atilde;o de jogos</li>
        </ul>
        <h4 id="h.r90z4becje49">Algoritmos de Programa&ccedil;&atilde;o Din&acirc;mica</h4>
        <ul>
            <li>[P1] Problema da Mochila (<em>Knapsack</em>) com e sem repeti&ccedil;&otilde;es</li>
            <li>[P1] An&aacute;lise combinat&oacute;ria com programa&ccedil;&atilde;o din&acirc;mica (por exemplo, calcular tri&acirc;ngulo de Pascal)</li>
            <li>[P1] Programa&ccedil;&atilde;o din&acirc;mica em prefixos de vetores/matrizes (por exemplo, Algoritmo de Kadane, Maior Subsequ&ecirc;ncia Comum, Dist&acirc;ncia de Edi&ccedil;&atilde;o)</li>
            <li>[P1] Programa&ccedil;&atilde;o din&acirc;mica em intervalos de vetores/matrizes (por exemplo, Multiplica&ccedil;&atilde;o de Cadeia de Matrizes)</li>
            <li>[P1] Programa&ccedil;&atilde;o din&acirc;mica em grafos direcionados ac&iacute;clicos (por exemplo, Problema do Caminho Mais Longo)</li>
            <li>[P1] Maior Subsequ&ecirc;ncia Crescente em <em>O</em>(<em>N</em> log&thinsp;<em>N</em>)</li>
            <li>[P2] Programa&ccedil;&atilde;o din&acirc;mica com m&aacute;scara de bits (por exemplo, encontrar caminho Hamiltoniano)</li>
        </ul>
        <h4 id="h.h4ro1t2wthdt">Algoritmos em Grafos</h4>
        <ul>
            <li>[PJ] Busca em Profundidade (DFS), incluindo aplica&ccedil;&otilde;es:</li>

            <ul>
              <li>Encontrar componentes conexas</li>
              <li>Encontrar biparti&ccedil;&atilde;o</li>
              <li>Preenchimento por Inunda&ccedil;&atilde;o (<em>Flood Fill</em> / DFS em <em>grids</em>)</li>
            </ul>

            <li>[PJ] Busca em Largura (BFS)</li>
            <li>[P1] Algoritmo de Dijkstra</li>
            <li>[P1] &Aacute;rvore geradora m&iacute;nima (algoritmos de Prim e Kruskal)</li>
            <li>[P1] Ordena&ccedil;&atilde;o topol&oacute;gica (algoritmo de Kahn)</li>
            <li>[P2] Algoritmos de Bellman-Ford e Floyd-Warshall</li>
            <li>[P2] Aplica&ccedil;&otilde;es de &aacute;rvore geradora da DFS (<em>DFS traversal tree</em>), incluindo:</li>
            <ul>
              <li>Caminho/ciclo de Euler</li>
              <li>Algoritmos de Tarjan para pontes e pontos de articula&ccedil;&atilde;o</li>
            </ul>

            <li>[P2] Componentes fortemente conexas (algoritmo de Kosaraju ou Tarjan)</li>
        </ul>
        <h4 id="h.o0ns0u6pwzye">Algoritmos em &Aacute;rvores</h4>
        <ul>
            <li>[P1] Aumenta&ccedil;&atilde;o de sub&aacute;rvores em &aacute;rvores enraizadas (por exemplo, calcular o tamanho ou a folha mais distante para cada sub&aacute;rvore)</li>
            <li>[P1] Di&acirc;metro e centro de &aacute;rvore em <em>O(N)</em></li>
            <li>[P2] Grafos funcionais (decomposi&ccedil;&atilde;o em ciclos e &aacute;rvores)</li>
            <li>[P2] <em>Binary Lifting</em> e Ancestral Comum Mais Profundo (LCA) em <em>O</em>(log&thinsp;<em>N</em>)</li>
            <li>[P2] Centroide de &aacute;rvore em <em>O(N)</em></li>
            <li>[P2] Pr&eacute;-ordem, em-ordem, p&oacute;s-ordem e t&eacute;cnica de Lineariza&ccedil;&atilde;o de &Aacute;rvore (<em>Euler Tour Technique</em>)</li>
            <li>[P2] Programa&ccedil;&atilde;o din&acirc;mica em &aacute;rvores enraizadas com t&eacute;cnica de Girar Raiz (<em>Tree Rerooting</em>)</li>
            <li>[P2] T&eacute;cnica <em>Small-to-Large</em> para unir sub&aacute;rvores</li>
        </ul>
        <h4 id="h.p88ll6a9id8l">Algoritmos de Geometria</h4>
        <ul>
            <li>[P2] Representa&ccedil;&atilde;o de vetores, retas e segmentos de reta</li>
            <li>[P2] Compress&atilde;o de coordenadas</li>
            <li>[P2] Produto escalar e vetorial, incluindo aplica&ccedil;&otilde;es:</li>

            <ul>
              <li>Checar se tr&ecirc;s pontos s&atilde;o colineares</li>
              <li>Testar se dois vetores s&atilde;o paralelos/ortogonais</li>
              <li>Calcular sentido do &acirc;ngulo entre dois vetores</li>
            </ul>

            <li>[P2] Interse&ccedil;&atilde;o de duas retas</li>
            <li>[P2] T&eacute;cnicas de Varredura (<em>Line Sweep, Radial Sweep</em>)</li>
            <li>[P2] Fecho Convexo (</em>Convex Hull</em>) em <em>O(N </em>log&thinsp;<em>N)</em></li>
            <li>[P2] &Aacute;rea de pol&iacute;gono em <em>O(N)</em> (F&oacute;rmula do Cadar&ccedil;o ou equivalente)</li>
            <li>[P2] Checar se um ponto est&aacute; em um pol&iacute;gono em <em>O(N)</em> (<em>Ray Casting</em> ou equivalente)</li>
        </ul>
<p></p>
